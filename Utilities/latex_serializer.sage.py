

# This file was *autogenerated* from the file latex_serializer.sage
from sage.all_cmdline import *   # import sage library
import query

_sage_const_5 = Integer(5)#Problems:

def apply_defaults(fn):
    def wrapper(obj, *args, **kwargs):
        return fn(obj, *args, **{**obj._opts, **kwargs})
    return wrapper

def reduce_data_opts(table, opts):
    return {**table._opts, **opts}

def reduce_col_title_opts(table, opts):
    data_kwargs = reduce_data_opts(table, opts)
    col_title_opts = {**table._opts['col_title_opts'], **opts, **opts['col_title_opts']}
    return {**reduce_data_opts(table, opts), 'col_title_opts': col_title_opts}

def serialize_args(fn):
    def wrapper(obj, *args, **kwargs):
        return fn(obj, *(obj._serializer.serialize(*args, **kwargs)), **kwargs)
    return wrapper

def serialize(projection, inclusion):
    def decorator(fn):
        def wrapper(instance, *args, **kwargs):
            return fn(
                instance,
                *inclusion(instance._serializer.serialize(*projection(args), **kwargs), args),
                **kwargs
            )
        return wrapper
    return decorator

class Latex_Serializer:
    # Depends on 'boldify' macro defined in TeX repo
    text_transformations = {
        'bold': lambda x: r"\boldify{" + str(x) + r"}",
        'italics': lambda x: r"\emph{" + str(x) + r"}"
    }
    serialization_type_defaults = {
        'text': True,
        'data': False,
        'expression_parser': latex
    }
    text_default_opts = {
        'bold': False,
        'italics': False,
        'parenthetical_units': None
    }
    datum_default_opts = {
        'post': lambda x: x,
        'pre': lambda x: x,     # Keeping 'transformation' for backwards compatibility
        'transformation': lambda x: x,
        'units': None,
        'show_units': True,
        'digits': _sage_const_5,
        'approximate': True,
        'exact_constants': {0, 1, pi, e},
        'tex': True,
        'math_mode': (r"$", r"$")
    }

    def __init__(self, **kwargs):
        self._opts = {
            **Latex_Serializer.datum_default_opts,
            **Latex_Serializer.text_default_opts,
            **Latex_Serializer.serialization_type_defaults,
            **kwargs
        }

    @staticmethod
    def _units(datum, **kwargs):
        out_units = kwargs.get('units', None)
        format_str = r"{:Lx}"
        try:
            datum = datum.to_base_units() if out_units == '' else datum.to(out_units)
        except:
            pass
        return format_str.format(datum)

    @staticmethod
    def _approx(datum, **kwargs):
        return n(datum, **kwargs)
    @staticmethod
    def _apply_math_mode(string, math_mode=(r"$", r"$")):
        return math_mode[0] + string + math_mode[1]
    def _is_exact_constant(self, val, **kwargs):
        vals = {'magnitude': lambda x: x.magnitude, 'expression': lambda x: x}
        return not set(kwargs['exact_constants']).isdisjoint(query.evaluate_query(val, vals).values())
    @apply_defaults
    def serialize_datum(self, datum, **kwargs):
        datum = kwargs['transformation'](datum)
        datum = kwargs['pre'](datum)
        if kwargs['digits'] and kwargs['approximate'] and not self._is_exact_constant(datum, **kwargs):
            # try/except to deal with cases like \infty
            try:
                datum = n(datum, digits=kwargs['digits'])
            except:
                pass
        ret = ''
        if kwargs['tex'] or kwargs['math_mode']:
            try:
                if kwargs['units'] is None:
                    datum = datum.to_base_units()
                else:
                    datum = datum.to(kwargs['units'])
                units = datum.units
                if not kwargs['show_units']:
                    datum /= units
                if not (size := datum.magnitude) == oo:
                    ret = '{:Lx}'.format(size*datum.units)
                else:
                    ret = r"$\infty$"
            except AttributeError:
                ret = kwargs['expression_parser'](datum)
        else:
            pass
        return Latex_Serializer._apply_math_mode(kwargs['post'](ret), math_mode=kwargs['math_mode'])
    @apply_defaults
    def serialize_text(self, arg, **kwargs):
        string = str(arg)
        if kwargs['parenthetical_units'] is not None:
            string += ' (' + '{:Lx}'.format(kwargs['parenthetical_units']) + ')'
        for key in Latex_Serializer.text_transformations.keys():
            if kwargs[key]:
                string = Latex_Serializer.text_transformations[key](string)
        return string
    @apply_defaults
    def serialize(self, *args, **kwargs):
        return [self._serialize(arg, **kwargs) for arg in args]
    def _serialize(self, arg, **kwargs):
        if isinstance(arg, list):
            return self.serialize(*arg, **kwargs)
        else:
            if kwargs['data']:
                arg = self.serialize_datum(arg, **kwargs)
            if kwargs['text']:
                arg = self.serialize_text(arg, **kwargs)
            return arg

#TODO Use query.sage to add generic serialization functions that consume nested dicts of options
#For example: Use query's `deep_get` to determine correct opts to apply to each serialized object
